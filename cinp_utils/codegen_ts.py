import os
from jinja2 import Environment


class_buff = ''


def tsType( cinpType ):
  suffix = ''
  if cinpType.get( 'is_array', False ):
    suffix = '[]'

  if cinpType[ 'type' ] == 'DateTime':
    return 'Date' + suffix

  elif cinpType[ 'type' ] == 'Map':
    return 'unknown' + suffix

  elif cinpType[ 'type' ] == 'Integer':
    return 'number' + suffix

  elif cinpType[ 'type' ] == 'Boolean':
    return 'boolean' + suffix

  else:
    return 'string' + suffix


def tsParamaters( paramater_list ):
  if not paramater_list:
    return '', '{}', ''

  func_in_parms = ' ' + ', '.join( [ '{0}: {1}'.format( i[ 'name' ], tsType( i ) ) for i in paramater_list ] ) + ' '
  func_obj_parms = '{ ' + ', '.join( [ '"{0}": {0}'.format( i[ 'name' ] ) for i in paramater_list ] ) + ' }'
  func_out_parms = ' ' + ', '.join( [ i[ 'name' ] for i in paramater_list ] ) + ' '

  return func_in_parms, func_obj_parms, func_out_parms


env = Environment()
env.filters[ 'tstype' ] = tsType
env.filters[ 'tsParamaters' ] = tsParamaters
service_header = env.from_string( """// Automatically generated by cinp-codegen from {{ url }} at {{ timestamp }}

import CInP from 'cinp'

class {{ service }}
{
  private cinp: CInP;

  constructor( host: string, server_error_handler: ( header: string, detail: string ) => void )
  {
    this.cinp = new CInP( host );
    const version = this.api_version();
    if( version != '{{ api_version }}' )
      throw 'API version mismatch.  Got "' + version + '", expected "{{ api_version }}"';

    if( typeof server_error_handler !== 'undefined' )
      this.cinp.server_error_handler = server_error_handler
  }

  api_version(): string
  {
    const ns = this.cinp.describe( '{{ root_path }}' );
    return ns[ 'api-version' ] ;
  }

  login( username: string, password: string ): void
  {
    this.Auth_User_call_login( username, password ).then( ( auth_token ) => this.cinp.setAuth( username, auth_token ) );
  }

  logout(): void
  {
    if ( this.cinp.isAuthencated() )
    {
      this.Auth_User_call_logout().then( () => this.cinp.setAuth( null, null ) );
    }
  }

""" )

service_footer = env.from_string( """
}

export default {{ service }};
""" )

ns_header = env.from_string( """
  // Namespace {{ name }} at {{ url }} version {{ api_version }}
/*
{{ doc }}
*/

""" )

ns_footer = env.from_string( """
  // Namespace {{ name }} (end)
""" )


model_methods_template = env.from_string( """{% set model_name = prefix + "_" + name %}
  // Model {{ name }} at {{ url }}
{% if 'GET' not in not_allowed_verb_list %}
  async {{ model_name }}_get( id: {{ id_field|tstype }} ): Promise<{{ model_name }}>
  {
    const response = await this.cinp.get( "{{ url }}:" + id + ":" ).then( res => res );

    return new {{ model_name }}( this, response.data[1] as {{ model_name }} );
  }
{% endif %}{% if 'CREATE' not in not_allowed_verb_list %}
  async {{ model_name }}_create( data: {{ model_name }} ): Promise<void>
  {
    const response = await this.cinp.create( "{{ url }}", data ).then( res => res );

    data.update( response.data[1] as {{ model_name }} );
  }
{% endif %}{% if 'UPDATE' not in not_allowed_verb_list %}
  async {{ model_name }}_update( id: {{ id_field|tstype }}, data: {{ model_name }} ): Promise<void>
  {
    const response = await this.cinp.update( "{{ url }}:" + id + ":", data ).then( res => res );

    data.update( response.data[1] as {{ model_name }} );
  }
{% endif %}{% if 'DELETE' not in not_allowed_verb_list %}
  async {{ model_name }}_delete( id: {{ id_field|tstype }} )
  {
    await this.cinp.delete( "{{ url }}:" + id + ":" ).then( res => res );
  }
{% endif %}{% if 'LIST' not in not_allowed_verb_list %}
  async {{ model_name }}_list( filter_name: string, filter_value_map: unknown, position: number, count: number )
  {
    const response = await this.cinp.list( "{{ url }}", filter_name, filter_value_map, position, count ).then( res => res );

    return response.data;
  }
{% endif %}{% if 'CALL' not in not_allowed_verb_list %}
{% for action in action_list %}
{%- set func_in_parms, func_obj_parms, _ = action.paramater_list|tsParamaters %}
{%- if not action.static %}{% set url = url + ':" + id + ":' %}{% endif %}
  async {{ model_name }}_call_{{ action.name }}({% if not action.static %} id: string, {% endif %}{{ func_in_parms }}): Promise<{% if action.return_type %}{{ action.return_type|tstype }}{% else %}void{% endif %}>
  {
    const response = await this.cinp.call( "{{ url }}({{ action.name }})", {{ func_obj_parms }} ).then( res => res );
    return ( response.data as {% if action.return_type %}{{ action.return_type|tstype }}{% else %}void{% endif %} );
  }

{% endfor %}{% endif %}
  // Model {{ name }} (end)
""" )

model_class_template = env.from_string( """{% set model_name = prefix + "_" + name %}
// Model {{ name }} from {{ prefix }} at {{ url }}
/*
{{ doc }}
*/
class {{ model_name }}
{
  private service: {{ service }};
{% for field in field_list %}
  public {{ field.name }} : {{ field|tstype }};{% endfor %}

  constructor( service: {{ service }}, data: {{ model_name }} )
  {
    this.service = service;
    if( typeof data === 'object' )
    {
{%- for field in field_list %}
      this.{{ field.name }} = data.{{ field.name }};{% endfor %}
    }
  }

  update( data: {{ model_name }} )
  {
    {%- for field in field_list %}
      this.{{ field.name }} = data.{{ field.name }};{% endfor %}
  }

{% if 'UPDATE' not in not_allowed_verb_list %}
  async save(): Promise<void>
  {
    return this.service.{{ model_name }}_update( this.{{ id_field.name }}, this );
  }
{% endif %}{% if 'DELETE' not in not_allowed_verb_list %}
  async delete(): Promise<void>
  {
    return this.service.{{ model_name }}_delete( this.{{ id_field.name }} );
  }
{% endif %}{% if 'CALL' not in not_allowed_verb_list %}
{% for action in action_list %}
{%- set func_in_parms, _, func_out_parms = action.paramater_list|tsParamaters %}
{%- if not action.static %}{% set url = url + ':" + id + ":' %}{% endif %}
  async {{ action.name }}({% if not action.static %} id: string, {% endif %}{{ func_in_parms }}): Promise<{% if action.return_type %}{{ action.return_type|tstype }}{% else %}void{% endif %}>
  {
    return this.service.{{ model_name }}_call_{{ action.name }}({% if not action.static %} id, {% endif %}{{ func_out_parms }});
  }

{% endfor %}{% endif %}
}
""" )


def write_model( fp, prefix, model, service ):
  global class_buff

  id_field = None
  if model[ 'id_field_name' ] is not None:
    for field in model[ 'field_list' ]:
      if field[ 'name' ] == model[ 'id_field_name' ]:
        id_field = field
        break

    if id_field is None:
      raise ValueError( 'Unable to find id field "{0}" in model "{1}"({2})'.format( model[ 'id_field_name' ], model[ 'name' ], prefix ) )

  value_map = {
                'service': service,
                'prefix': prefix,
                'name': model[ 'name' ],
                'url': model[ 'url' ],
                'doc': model[ 'doc' ],
                'field_list': model[ 'field_list' ],
                'constant_map': model[ 'constant_map' ],
                'id_field': id_field,
                'list_filter_map': model[ 'list_filter_map' ],
                'not_allowed_verb_list': model[ 'not_allowed_verb_list' ],
                'action_list': model[ 'action_list' ]
              }

  fp.write( model_methods_template.render( **value_map ) )

  class_buff += model_class_template.render( **value_map )


def write_namespace( fp, prefix, namespace, service ):
  if prefix:
    prefix = '{0}_{1}'.format( prefix, namespace[ 'name' ] )
  else:
    prefix = namespace[ 'name' ]

  value_map = {
                'name': namespace[ 'name' ],
                'url': namespace[ 'url' ],
                'doc': namespace[ 'doc' ],
                'api_version': namespace[ 'api_version' ]
              }
  fp.write( ns_header.render( **value_map ) )

  for model in namespace[ 'model_list' ]:
    write_model( fp, prefix, model, service )

  for child in namespace[ 'namespace_list' ]:
    write_namespace( fp, prefix, child, service )

  fp.write( ns_footer.render( **value_map ) )


def ts_render_func( wrk_dir, header_map, root ):
  header_map[ 'api_version' ] = root[ 'api_version' ]
  root[ 'name' ] = ''

  with open( os.path.join( wrk_dir, '{0}.ts'.format( header_map[ 'service' ] ) ), 'w' ) as fp:  # TODO: make sure this is filsystem safe
    fp.write( service_header.render( **header_map ) )
    write_namespace( fp, '', root, header_map[ 'service' ] )
    fp.write( service_footer.render( **header_map ) )

    fp.write( class_buff )
